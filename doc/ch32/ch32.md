# 32장 네트워크 유량(Network Flow)

## 1) 배경

네트워크 유량은 특정한 지점에서 다른 지점으로 데이터가 얼마나 많이 흐르고 있는가를 측정하는 알고리즘입니다. 이러한 알고리즘은 교통 체증, 네트워크 데이터 전송 등의 다야안 분야에 활용되고 있습니다.

![1](images/1.jpg)

네트워크를 이용해 수백 GB에 달하는 아주 큰 파일을 다운로드 하는 중이라고 합시다. 이렇게 전송받을 자료의 양이 많을때 우리가 관심을 갖는 부분은 서버가 보낸 패킷이 내 컴퓨터에 몇미리초 만에 도착하는 것이 아니라, 1초에 몇 MB의 자료를 전송 받을 수 있느냐입니다. 네트워크 유량(Network Flow)는 이렇게 각 간선이 용량을 갖는 그래프에서 두 정점 사이에 얼마나 많은 흐름, 유량을 보낼 수 있는지를 계산하는 문제에서 시작되었습니다.

결론)
Network Flow란?

그래프에 서로 다른 두 정점인 **소스 S**(source), **싱크 T**(sink) 정점이 정해지고,
소스 정점에서 유량을 발생시켜서 간선들을 통해 싱크 정점에 많은 유량을 흘려 보내는것이 목표

![9](images/9.jpg)

## 2) 용어 설명

용량(Capacity): 간선에 흘릴수 있는 최대 데이터 양
유량(Flow): 간선에 흐르는 데이터 양
소스(Source) : 시작 정점, S로 주로 표시됨
싱크(Sink): 도착 정점, T로 주로 표시됨

### 예시 1)

각 도시를 지날때 1초가 걸리고 각 길의 폭은 8(서울->대전), 3(대전->부산)이라고 하자.
사람 1명당 1개의 폭을 차지 한다고 할때 서울에서 부산으로 1초당 몇명을 보내야 막힘이 없이 안정적으로 갈 수 있을까? 

- Source: 서울, Sink: 부산

![2](images/2.jpg)

- 서울 -> 대전 용량(Capacity) : 8,  대전 -> 부산  용량(Capacity) : 3

![3](images/3.jpg)

- 서울에서 부산으로 8명을 한번에 보냈을 경우

![4](images/4.jpg)

- 1초에 3명씩 서울에서 부산으로 보내야 막힘 없이 안정적으로 보낼 수 있다. (표현 방식: 유량/용량)

### 예시 2)

A에서 D로 최대한 많은 유량을 보내려고 할 때 가장 합리적인 양은 얼마일까?

![5](images/5.jpg)

- 6이상을 보내면 정체 현상이 발생할 수 있다. 여기서 6을 최대유량(Max Flow)라고 한다.

![6](images/6.jpg)



## 3) 포드-풀커슨 알고리즘

이제 한 번 여러개의 정점과 간선이 있는 경우를 확인해 봅시다.

참고) 네트워크 유량을 해결하는 가장 기초적인 방법으로 포드-풀커슨 알고리즘이 있습니다. 포드-풀커슨 알고리즘은 알고리즘 방법론으로 구현 방식은 다양하나 jongman book에서는 너비우선탐색으로 포드-풀커슨 알고리즘을 이용하여 구현한 에드몬드-카프 알고리즘에 대해 설명하고 있습니다.

- **유량 그래프의 성질**

  1. 각 간선에 흐르는 유량은 그 간선의 용량을 넘어서는 안 됩니다. flow(u, v) ≤ capacity(u, v)

  2. S와 T를 제외한 정점에서는 **들어오는 유량 총합과 나가는 유량 총합이 같아야 합니다.**
     ex) 2번 정점에 들어오는 유량의 총합과 나가는 총합은 같아야 합니다.

  3. 간선 (u, v) 방향으로 유량이 흐르고 있다면, **역방향으로는 음의 유량이 그만큼 흐르고 있는 것으로 취급합니다.**

     즉, f(u, v) = -f(v, u)입니다.

     위의 두 성질보다는 좀 덜 당연한데, 이 성질은 추후 최대 유량을 구해내는 알고리즘에서 유용하게 써먹습니다.



- **핵심 Idea:**
  유량 그래프의 성질의 기반으로 정해진 용량(Capacity) 안에서 가능한 용량의 양을 반복적으로 더해준다.
  남아있는 용령이 1이 넘으면 계속해서 흘려 내보내주면 최적화가 이루어 진다.
  유량을 흘려보내는 것을 도중에 멈춰서는 안 되고, 반드시 Sink인 6까지 도달해야만 유효합니다.

![7](images/7.png)

### 포드-풀커슨 알고리즘 설명

- 가능한 모든 경우의 수를 탐색하기 위해 유량(Flow)를 0으로 초기화, 유량(f)/용량(c)으로 표시

![10](images/10.jpg)

선택: [S, A, E, T]

![11](images/11.jpg)

선택: [S, B, E, T]

![12](images/12.jpg)

선택: [S, C, F, T]

![13](images/13.jpg)

증가 경로를 더 찾을 수 없어 보임.. 여기서 **최대 유량은 9**

여기서 유량 그래프의 3번째 성질을 사용함 f(u, v) = -f(v, u)

![14](images/14.jpg)



선택: [S, C, F, E, A, D, T]

![`15`](images/15.jpg)

**원래 정점 A에서 E로 흘려보내던 유량 3 중에서 1을 철수해서 다른 정점인 D로 흘려보내게 되었다**고 생각할 수가 있습니다.

최대 유량: 10

### 포드-풀커슨 알고리즘의 구현: 에드몬드 카프 알고리즘

```c++
#include<cstdio>
#include<queue>
#include<memory.h>
#include<algorithm>

using namespace std;
const int MAX_V = 111;
const int INF = 1 << 30;

int c[MAX_V][MAX_V];
int f[MAX_V][MAX_V];
int parent[MAX_V];

int residual(int here, int there) {
  return c[here][there] - f[here][there];
}

int edmonds_karp(int source, int sink) {

  int total = 0;
  while (true) {
     memset(parent, -1, sizeof(parent));
     queue<int> Q;
     Q.push(source);
     parent[source] = source;

     while (!Q.empty() && parent[sink] == -1) {
       int here = Q.front();

       Q.pop();
       for (int there = 0; there < MAX_V; there++) {
         if (residual(here, there) > 0 && parent[there] == -1) { 
           parent[there] = here;
           Q.push(there);
         }
       }
     }

     if (parent[sink] == -1) break;

     int mn = INF;
     for (int p = sink; p != source; p = parent[p]) {
       mn = min(c[parent[p]][p] - f[parent[p]][p], mn);
     }

     for (int p = sink; p != source; p = parent[p]) {
       f[parent[p]][p] += mn;
       f[p][parent[p]] -= mn;
     }
     total += mn;
  }
  return total;
}
```












